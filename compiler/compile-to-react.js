import fs from "fs";
import * as parser from "./parser.js";

const code = fs.readFileSync("uix/example.uix", "utf-8");
const tagMap = {
  App: "div", // This mapping for 'App' is now primarily for internal reference, not direct JSX tag generation for the root.
  Title: "h1",
  Row: "div",
  Button: "button",
  Input: "input",
  Text: "span"
};

const ast = parser.parse(code);
// console.log("--- DEBUG: Parsed AST ---");
// console.log(JSON.stringify(ast, null, 2));
// console.log("--- END DEBUG ---");

// Tracking
const usedIdentifiers = new Set();
const bindCandidates = new Map(); // Stores varName -> initialValue for all 'bind' targets found in AST

function capitalize(str) {
  if (typeof str === "object" && str !== null && str.type === "expression") {
    str = str.value;
  }
  return typeof str === "string" ? str.charAt(0).toUpperCase() + str.slice(1) : "";
}

function extractIdentifiers(value) {
  if (typeof value === "object" && value !== null && value.type === "expression") {
    value = value.value;
  }
  if (typeof value === "string" && /^[a-zA-Z_$][a-zA-Z0-9_$.]*$/.test(value)) {
    const parts = value.split(".");
    usedIdentifiers.add(parts[0]); // Add the root identifier (e.g., 'user' from 'user.name')
  }
}

// Function to recursively collect all bind candidates and used identifiers from the AST
function collectAllIdentifiers(node) {
  if (!node) return;

  // Handle props for standard elements
  if (node.props) {
    for (const [key, value] of Object.entries(node.props)) {
      if (key === "bind") {
        if (typeof value === 'object' && value !== null && value.type === 'expression') {
          const varName = value.value;
          if (/^[a-zA-Z_$][a-zA-Z0-9_]*$/.test(varName)) { // Ensure it's a simple identifier
            const initialValue = node.props.initial !== undefined
              ? (typeof node.props.initial === 'object' && node.props.initial !== null && node.props.initial.type === 'expression' ? node.props.initial.value : node.props.initial)
              : "";
            bindCandidates.set(varName, initialValue);
            usedIdentifiers.add(varName); // Mark the variable itself as used
            usedIdentifiers.add(`set${capitalize(varName)}`); // Mark its setter as used
          } else {
            console.warn(`Warning: 'bind' prop requires a simple identifier string. Found: '${varName}'.`);
          }
        }
      } else if (key !== "text" && key !== "initial" && key !== "bindDefault") { // 'text', 'initial', 'bindDefault' are handled elsewhere or internal
        // For other props, if they are expressions, extract their identifiers
        if (typeof value === 'object' && value !== null && value.type === 'expression') {
          extractIdentifiers(value.value);
        } else if (typeof value === 'string' && key.startsWith("on")) {
          // For simple string event handlers like onClick: greet, extract 'greet'
          extractIdentifiers(value);
        }
      }
    }
  }

  // Handle If block condition
  if (node.type === "If" && node.condition) {
    extractIdentifiers(node.condition.value);
  }

  // Handle For block list and item
  if (node.type === "For" && node.list) {
    extractIdentifiers(node.list.value);
    usedIdentifiers.add(node.item); // The loop item variable
  }

  // Recursively process children
  (node.children || []).forEach(collectAllIdentifiers);
}

// Initial pass to collect all identifiers and bind candidates from the entire AST
ast.forEach(collectAllIdentifiers);

// Determine which bind candidates will become internal state
const internalStates = new Map(); // varName -> initialValue for actual internal state
bindCandidates.forEach((initialValue, varName) => {
  const setterName = `set${capitalize(varName)}`;
  // If the setter for a bind candidate is NOT explicitly used in the UIX
  // (meaning it's not passed as a prop from the parent), then it should be internal state.
  // If the setter IS used, it implies the parent is managing this state.
  if (!usedIdentifiers.has(setterName)) {
     internalStates.set(varName, initialValue);
  }
});


// Converts a props object to JSX string
function renderProps(props, nodeType) { // Pass nodeType to allow special handling
  const safeProps = props || {};
  const jsxProps = [];

  // Track if a 'bind' prop was found for this element
  let bindVarName = null;
  if (nodeType === 'Input' && safeProps.bind && typeof safeProps.bind === 'object' && safeProps.bind.type === 'expression') {
    bindVarName = safeProps.bind.value;
  }

  for (const [key, value] of Object.entries(safeProps)) {
    // Skip internal compiler props like 'bind', 'initial', 'bindDefault'
    if (["bind", "initial", "bindDefault", "text"].includes(key)) {
      continue;
    }

    // If this is an Input with a 'bind' prop, we handle 'value' and 'onChange' specifically
    if (nodeType === 'Input' && bindVarName && (key === 'value' || key === 'onChange')) {
      // These will be generated by the bind logic below, so skip them here
      continue;
    }

    // Handle event handlers (e.g., onClick, onInput)
    if (key.startsWith("on")) {
      if (typeof value === "object" && value !== null && value.type === "expression") {
        extractIdentifiers(value.value);
        jsxProps.push(`${key}={${value.value}}`);
      } else if (typeof value === "string") {
        extractIdentifiers(value);
        jsxProps.push(`${key}={${value}}`);
      } else {
        jsxProps.push(`${key}={${JSON.stringify(value)}}`);
      }
    }
    // Handle expression values from the parser
    else if (typeof value === 'object' && value !== null && value.type === 'expression') {
      extractIdentifiers(value.value); // Extract identifiers from the expression string
      jsxProps.push(`${key}={${value.value}}`);
    }
    // Handle string literal values for other props
    else if (typeof value === "string") {
      jsxProps.push(`${key}=${JSON.stringify(value)}`); // Ensure string literals are quoted in JSX
    }
    // Handle other types (numbers, booleans, objects) by stringifying and wrapping in curly braces
    else {
      jsxProps.push(`${key}={${JSON.stringify(value)}}`);
    }
  }

  // Add 'value' and 'onChange' for 'bind'ed Inputs
  if (nodeType === 'Input' && bindVarName) {
    const setterName = `set${capitalize(bindVarName)}`;
    jsxProps.push(`value={${bindVarName}} onChange={e => ${setterName}(e.target.value)}`);
  }

  return jsxProps.join(" ");
}

// Generate JSX for a given AST node
function generateJSX(node, indent = "  ") {
  const { type, props, children } = node;
  const childIndent = indent + "  ";

  // Special handling for top-level 'App' node: its children form the main body
  if (type === "App") {
    return (children || []).map(c => generateJSX(c, indent)).join("\n");
  }

  // Handle 'If' blocks (conditional rendering)
  if (type === "If") {
    const innerChildren = children.map(c => generateJSX(c, childIndent)).join("\n");
    return `${indent}{${node.condition.value} ? (\n${innerChildren}\n${indent}) : null}`;
  }

  // Handle 'For' blocks (list rendering)
  if (type === "For") {
    const innerChildren = children.map(c => generateJSX(c, childIndent + "  ")).join("\n");
    return `${indent}{${node.list.value}.map((${node.item}, index) => (\n${childIndent}  <React.Fragment key={typeof ${node.item} === 'object' && ${node.item} !== null && 'id' in ${node.item} ? ${node.item}.id : index}>\n${innerChildren}\n${childIndent}  </React.Fragment>\n${indent}))}`;
  }

  // Handle standard elements
  const jsxTag = tagMap[type] || type; // Translate UIX tag to HTML tag or use as-is
  const propStr = renderProps(props, type); // Pass node type to renderProps for context

  let innerContent = [];

  // Handle 'text' prop for direct text content within the element
  if (props !== null && typeof props === 'object' && props.text !== undefined) {
    const textValue = props.text;
    if (typeof textValue === 'object' && textValue !== null && textValue.type === 'expression') {
      innerContent.push(`{${textValue.value}}`);
    } else {
      innerContent.push(textValue); // Direct text content in JSX does not need JSON.stringify
    }
  }

  // Add children JSX after the text content
  innerContent.push(...(children || []).map(c => generateJSX(c, childIndent)));

  const inner = innerContent.filter(Boolean).join("\n");

  if (inner.trim() === "") {
    return `${indent}<${jsxTag}${propStr ? " " + propStr : ""} />`;
  } else {
    return `${indent}<${jsxTag}${propStr ? " " + propStr : ""}>\n${inner}\n${indent}</${jsxTag}>`;
  }
}

// Separate component definitions from the main app body
const componentDefinitions = ast.filter(node => node.type === "ComponentDefinition");
const appBodyNodes = ast.filter(node => node.type !== "ComponentDefinition");

let mainJsxBody = '';
if (appBodyNodes.length > 0) {
  // If there's an 'App' node, its children form the root JSX body
  const appNode = appBodyNodes.find(node => node.type === 'App');
  if (appNode) {
    mainJsxBody = generateJSX(appNode); // This will handle its children directly
  } else {
    // If no 'App' node but other top-level elements, treat them as the main body
    mainJsxBody = appBodyNodes.map(node => generateJSX(node)).join("\n");
  }
}

// Determine which variables should be passed as props to CompiledUI
// These are identifiers used in the main app body that are NOT internal state variables or their setters
const propsToInject = Array.from(usedIdentifiers).filter(id => {
  const varName = id.startsWith("set") ? id.slice(3) : id;
  // A prop if it's used, AND it's not an internal state variable AND not an internal state setter
  return !internalStates.has(varName) && !internalStates.has(id);
}).sort();

// Generate useState hooks for internal states
const autoStates = Array.from(internalStates.entries())
  .map(([varName, initialValue]) => {
    const stateInit = typeof initialValue === 'string' && /^[a-zA-Z_$][a-zA-Z0-9_$.]*$/.test(initialValue)
      ? initialValue
      : JSON.stringify(initialValue);
    return `  const [${varName}, set${capitalize(varName)}] = React.useState(${stateInit});`;
  })
  .join("\n");

const propDestructure = propsToInject.join(", ");

// Generate custom React components
const customComponentsJsx = componentDefinitions.map(compDef => {
  const componentName = compDef.name;
  const componentBodyJsx = compDef.body.map(node => generateJSX(node, "    ")).join("\n"); // Indent children of component body

  // For simplicity, assume component props are passed explicitly in UIX
  // For now, components don't have their own state/prop tracking in this simple compiler.
  // They will receive props from their parent if used.
  return `
function ${componentName}(props) {
  return (
    <>
${componentBodyJsx}
    </>
  );
}`;
}).join("\n");


const output = `// Auto-generated by UIX compiler
import React from "react";
${customComponentsJsx}

export default function CompiledUI({ ${propDestructure} }) {
${autoStates ? autoStates + "\n" : ""}
  // IMPORTANT: Ensure that any props listed in the destructuring (e.g., 'users', 'greet', 'showMore', 'toggle')
  // are passed down from the parent component that renders <CompiledUI />.
  // For 'bind' targets like 'name' that are managed by the parent, ensure 'name' and 'setName' are passed.

  return (
    <>
${mainJsxBody}
    </>
  );
}
`;

fs.writeFileSync("src/CompiledUI.jsx", output);
console.log("✅ Compiled: src/CompiledUI.jsx");
console.log("--- START OF GENERATED JSX ---");
console.log(output);
console.log("--- END OF GENERATED JSX ---");
console.log("✅ Injected props:", propDestructure || "(none)");
if (internalStates.size > 0) {
  console.log("✅ Injected state for:", Array.from(internalStates.keys()).join(", "));
}
